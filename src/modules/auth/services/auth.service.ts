import { User, UserPayload } from "@/types/user.entity";
import http from "@/lib/http";
import type { NetworkType } from "@/types/network.entity";
import { Status } from "@trustless-work/escrow";

interface CreateUserResponse {
  status: Status;
  user: User;
}

interface ApiErrorResponse {
  message: string;
  error: string;
  statusCode: number;
}

interface AxiosErrorResponse {
  response: {
    status: number;
    data: ApiErrorResponse;
  };
}

// New API Keys types based on backend responses
interface ApiKeyRecord {
  id: string;
  userId: string;
  roles: string[];
  createdAt?:
    | { _seconds: number; _nanoseconds: number }
    | { seconds: number; nanoseconds: number }
    | string;
  lastUsedAt?:
    | { _seconds: number; _nanoseconds: number }
    | { seconds: number; nanoseconds: number }
    | string;
  lastUsedFromIp?: string;
  active?: boolean;
  expiresAt?:
    | { _seconds: number; _nanoseconds: number }
    | { seconds: number; nanoseconds: number }
    | string
    | null;
}

interface ApiKeyCreationResponse {
  success: boolean;
  data: {
    apiKey: string;
    id: string;
    userId: string;
    roles: string[];
    createdAt: string;
  };
  message: string;
}

export class AuthService {
  private buildUrl(path: string): string {
    // Always return relative path so requests go through the proxy,
    // which attaches the appropriate server-side API key.
    return path;
  }

  async createUser(address: string): Promise<CreateUserResponse> {
    try {
      const response = await http.post("/user/create", { address });
      return response.data;
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  async updateUser(address: string, updateData: UserPayload): Promise<User> {
    try {
      const response = await http.put(`/user/${address}`, updateData);
      return response.data;
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  async getAllUsers(): Promise<User[]> {
    try {
      const response = await http.get("/user/get-all");
      return response.data;
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  async getUser(address: string): Promise<User | null> {
    try {
      const response = await http.get(`/user/${address}`);
      return response.data;
    } catch (error: unknown) {
      if (error && typeof error === "object" && "response" in error) {
        const axiosError = error as AxiosErrorResponse;
        if (axiosError.response?.status === 404) {
          return null;
        }
      }
      console.error(error);
      throw error;
    }
  }

  async requestApiKey(
    userId: string,
    network?: NetworkType,
  ): Promise<ApiKeyCreationResponse> {
    try {
      const response = await http.post(
        this.buildUrl("/admin/api-keys"),
        {
          userId,
          roles: ["ESCROW_MANAGER"],
          expiresAt: null,
          description: "Generated by Trustless Work | Backoffice",
        },
        network ? { headers: { "x-network": network } } : undefined,
      );
      return response.data;
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  async getUserApiKeys(
    userId: string,
    network?: NetworkType,
  ): Promise<{ success: boolean; data: ApiKeyRecord[]; userId: string }> {
    try {
      const response = await http.get(
        this.buildUrl(`/admin/api-keys/user/${userId}`),
        network ? { headers: { "x-network": network } } : undefined,
      );
      return response.data;
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  async deleteApiKey(
    keyId: string,
    network?: NetworkType,
  ): Promise<{ success: boolean; message?: string }> {
    try {
      const response = await http.delete(
        this.buildUrl(`/admin/api-keys/${keyId}`),
        network ? { headers: { "x-network": network } } : undefined,
      );
      return response.data;
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
}
